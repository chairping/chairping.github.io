---
layout:    post
title:     "Lumen源码阅读－－－容器"
subtitle:  "Container"
date:       2016-3-23 21:50
---

###   ioc容器 


###  Illuminate\Container\Container.php
 
{% highlight php startinline %}
    
class Container implements ArrayAccess, ContainerContract
{

    protected static $instance;

    /**
     * An array of the types that have been resolved.
     *　该数组标示　注册的服务是否已解析
     * @var array
     */
    protected $resolved = [];

    /**
     * The container's bindings.
     *　容器中的绑定
     * @var array
     */
    protected $bindings = [];

    /**
     * The container's shared instances.
     *　容器中的共享实例
     * @var array
     */
    protected $instances = [];

    /**
     * The registered type aliases.
     *
     * @var array
     */
    protected $aliases = [];

    /**
     * The extension closures for services.
     *
     * @var array
     */
    protected $extenders = [];

    /**
     * All of the registered tags.
     *
     * @var array
     */
    protected $tags = [];

    /**
     *　该栈的数据是临时保存的　等解析结束后会被清空　提供给上下文绑定操作
     * @var array
     */
    protected $buildStack = [];

    /**
     *　上下文绑定关系数组　
     * @var array
     */
    public $contextual = [];

    /**
     * @var array
     */
    protected $reboundCallbacks = [];

    /**
     * @var array
     */
    protected $globalResolvingCallbacks = [];

    /**
     * @var array
     */
    protected $globalAfterResolvingCallbacks = [];

    /**
     * @var array
     */
    protected $resolvingCallbacks = [];

    /**
     * @var array
     */
    protected $afterResolvingCallbacks = [];

    /**
     * 定义一个上下文绑定
     * @param  string  $concrete
     * @return \Illuminate\Contracts\Container\ContextualBindingBuilder
     */
    public function when($concrete)
    {
        $concrete = $this->normalize($concrete);

        return new ContextualBindingBuilder($this, $concrete);
    }

    /**
     * bound 是　bind 过去式　意味着提供的抽象类型是否已经绑定过了
     *
     * @param  string  $abstract
     * @return bool
     */
    public function bound($abstract)
    {
        $abstract = $this->normalize($abstract);

        return isset($this->bindings[$abstract]) || isset($this->instances[$abstract]) || $this->isAlias($abstract);
    }

    /**
     *　判断抽象类型是否已经解析过的　
     * @param  string  $abstract
     * @return bool
     */
    public function resolved($abstract)
    {
        $abstract = $this->normalize($abstract);

        if ($this->isAlias($abstract)) {
            $abstract = $this->getAlias($abstract);
        }

        return isset($this->resolved[$abstract]) || isset($this->instances[$abstract]);
    }

    /**
     * Determine if a given string is an alias.
     *　
     * @param  string  $name
     * @return bool
     */
    public function isAlias($name)
    {
        return isset($this->aliases[$this->normalize($name)]);
    }
    
    /**
    * 向容器中注册    
    * @param  string|array  $abstract　表示抽象类型
    * 　　　　　　　1. 　string  类名称    2.   array  [类名称，　别名]       
    * @param  \Closure|string|null  $concrete 　表示具体类型　如果是string|null 最终转化成匿名函数保存  
    * @param bool  $shared   
	*			true 表示共享, 每次返回同一个对象
	*	　		false　每次返回新的对象
    */
    public function bind($abstract, $concrete = null, $shared = false)
    {
        // 格式类名字符串　
        $abstract = $this->normalize($abstract);
        $concrete = $this->normalize($concrete);

        // 如果 abstract 是数组，　则就认为一维数组 key为实际类名　　value 为别名　
        //　也即动态设置别名 获取的时候可直接通过　别名　获取　
        if (is_array($abstract)) {
            list($abstract, $alias) = $this->extractAlias($abstract);
            $this->alias($abstract, $alias);
        }
        
        //　清楚上次绑定的Container::instances Container::alias对应缓存的数据　
        //  bind 可多次绑定相同的类型，所以第n(n>1)次绑定的时候都要清除之前绑定的数据
        //  bindIf方法　可防止多次绑定，　效果：　如果该类型已经绑定过了　则不进行该次绑定操作
        $this->dropStaleInstances($abstract);

        // 如果具体类型为null 则设置具体类型为抽象类型
        if (is_null($concrete)) {
            $concrete = $abstract;
        }

        // 如果具体类型非匿名函数　则格式化成匿名函数
        if (! $concrete instanceof Closure) {
            $concrete = $this->getClosure($abstract, $concrete);
        }

        // 记录绑定类型详情
        // 1 concrete　　匿名函数　function($c[, $param]) {}
        // 2 shared true 为共享　　当share 为true时，　make操作会把该匿名函数返回的结果保存到Container::instances 中，　达到共享效果
        $this->bindings[$abstract] = compact('concrete', 'shared');

        // If the abstract type was already resolved in this container we'll fire the
        // rebound listener so that any objects which have already gotten resolved
        // can have their copy of the object updated via the listener callbacks.
        // 如果抽象类型解析过　即通过make操作(make操作有开发人员调用　和　容器自动解析两种)
        // 则更新该类型数据　和　触发监听回调(如果有设置的话)
        if ($this->resolved($abstract)) {
            $this->rebound($abstract);
        }
    }
    
    protected function getClosure($abstract, $concrete)
    {
        // $c 表示　容器实例　$parameters 表示参数　　
        // 该函数返回的匿名函数保存在　$this->bindings[$abstract] = ['concrete' => 匿名函数]
        // 当解析的时候，　即make操作，　会执行该匿名函数　最终返回我们需要的数据。
        // 
        return function ($c, $parameters = []) use ($abstract, $concrete) {
            // 解析　
            $method = ($abstract == $concrete) ? 'build' : 'make';
   
            return $c->$method($concrete, $parameters);
        };
    }
    
    
{% endhighlight %}
	
　　１．　一个参数
	app()->bind(class_name);　//表示 使用app('class_name')；　class_name通常是　能实例化的类的类名　获取　别名　
	
	２.  两个参数   
	app()->bind(abstract, class_name);　// 通常第一个表示接口名称(或其别名)　第二个表示实现该接口的类名称。
　　
	例子：

	app()->bind(abstract, function() {
		return new Object;
	});

